import io
import numpy as np
import pandas as pd
import seaborn as sns
#import warning
import matplotlib.pyplot as plt
#from pylab import rcParams
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score,recall_score
from sklearn.metrics import f1_score,roc_auc_score,roc_curve
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report,accuracy_score,confusion_matrix
from collections import Counter
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
df=pd.read_csv('creditcard.csv')
df1=pd.read_csv('creditcard.csv')
columns_not_normalised=['Class']
columns_to_normalise=[x for x in df.columns if x not in columns_not_normalised]
for i in columns_to_normalise:
  df[i] = ( df[i] - df[i].mean() ) / df[i].std()
x_columns=[x for x in df.columns if x != 'Class']
y_column='Class'

X=df[x_columns]
Y=df[y_column]
X_train,X_test,Y_train,Y_test = train_test_split(X, Y, test_size=0.15, random_state=42)
train_data=pd.concat([X_train,Y_train],axis=1)
test_data=pd.concat([X_test,Y_test],axis=1)
X_train,X_vad,Y_train,Y_vad = train_test_split(X_train, Y_train, test_size=0.18, random_state=42)
X1=df1[x_columns]
Y1=df1[y_column]
X1_train,X1_test,Y1_train,Y1_test = train_test_split(X1, Y1, test_size=0.15, random_state=42)
train_data1=pd.concat([X_train,Y_train],axis=1)
test_data1=pd.concat([X_test,Y_test],axis=1)
X1_train,X1_vad,Y1_train,Y1_vad = train_test_split(X1_train, Y1_train, test_size=0.18, random_state=42)
print("original normalized train set shape",Counter(Y_train))
print("original normalized validation set shape",Counter(Y_vad))
print("original normalized test set shape",Counter(Y_test))

print("original train set shape",Counter(Y1_train))
print("original validation set shape",Counter(Y_vad))
print("original test set shape",Counter(Y1_test))
#implementing logistic regression on imbalanced normalized data
lr_classifier=LogisticRegression(random_state=0).fit(X_train,Y_train)
Y_pred=lr_classifier.predict(X_train)
n_errors = (Y_pred != Y_train).sum()
print("\n\ntrain")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_train,Y_pred))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_train,Y_pred))
print("_________________________________________________________________________________\n")
print("error: ",n_errors)
print("Accuracy Score :",accuracy_score(Y_train,Y_pred))
print("AUC :",roc_auc_score(Y_train,lr_classifier.predict_proba(X_train)[:,1]))
Y_pred_vad=lr_classifier.predict(X_vad)
n_errors = (Y_pred_vad != Y_vad).sum()
print("\n\nvalidation")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_vad,Y_pred_vad))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_vad,Y_pred_vad))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_vad,Y_pred_vad))
print("AUC :",roc_auc_score(Y_vad,lr_classifier.predict_proba(X_vad)[:,1]))
Y_pred_test=lr_classifier.predict(X_test)
n_errors = (Y_pred_test != Y_test).sum()
print("\n\ntest")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_test,Y_pred_test))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_test,Y_pred_test))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_test,Y_pred_test))
print("AUC :",roc_auc_score(Y_test,lr_classifier.predict_proba(X_test)[:,1]))
#implementing decision tree classifier on imbalanced non normalized data
dt_classifier=DecisionTreeClassifier(criterion="entropy",random_state=0)
dt_classifier.fit(X1_train,Y1_train)
Y1_pred_train=dt_classifier.predict(X1_train)
n_errors = (Y1_pred_train != Y1_train).sum()
print("\n\ntrain")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y1_train,Y1_pred_train))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y1_train,Y1_pred_train))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y1_train,Y1_pred_train))
print("AUC :",roc_auc_score(Y1_train,dt_classifier.predict_proba(X1_train)[:,1]))
Y1_pred_vad=dt_classifier.predict(X1_vad)
n_errors = (Y1_pred_vad != Y1_vad).sum()
print("\n\nvalidation")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y1_vad,Y1_pred_vad))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y1_vad,Y1_pred_vad))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y1_vad,Y1_pred_vad))
print("AUC :",roc_auc_score(Y1_vad,dt_classifier.predict_proba(X1_vad)[:,1]))
Y1_pred_test=dt_classifier.predict(X1_test)
n_errors = (Y1_pred_test != Y1_test).sum()
print("\n\ntest")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y1_test,Y1_pred_test))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y1_test,Y1_pred_test))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y1_test,Y1_pred_test))
print("AUC :",roc_auc_score(Y1_test,dt_classifier.predict_proba(X1_test)[:,1]))
#Randomly undersampling normalized training data
from imblearn.under_sampling import RandomUnderSampler
rus = RandomUnderSampler(random_state=42, replacement=False,sampling_strategy=0.02)
X_train_rus, Y_train_rus = rus.fit_resample(X_train, Y_train)
print('original train dataset shape:', Counter(Y_train))
print('Resample dataset shape', Counter(Y_train_rus))
#Applying logistic regression on randomly undersampled normalized training data
lr_classifier_rus=LogisticRegression(random_state=0).fit(X_train_rus,Y_train_rus)
Y_pred_lr_rus_train=lr_classifier_rus.predict(X_train_rus)
n_errors = (Y_pred_lr_rus_train != Y_train_rus).sum()
print("\n\ntrain")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_train_rus,Y_pred_lr_rus_train))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_train_rus,Y_pred_lr_rus_train))
print("_________________________________________________________________________________\n")
print("error: ",n_errors)
print("Accuracy Score :",accuracy_score(Y_train_rus,Y_pred_lr_rus_train))
print("AUC :",roc_auc_score(Y_train_rus,lr_classifier_rus.predict_proba(X_train_rus)[:,1]))
Y_pred_lr_rus_vad=lr_classifier_rus.predict(X_vad)
n_errors = (Y_pred_lr_rus_vad != Y_vad).sum()
print("\n\nvalidation")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_vad,Y_pred_lr_rus_vad))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_vad,Y_pred_lr_rus_vad))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_vad,Y_pred_lr_rus_vad))
print("AUC :",roc_auc_score(Y_vad,lr_classifier_rus.predict_proba(X_vad)[:,1]))
Y_pred_lr_rus_test=lr_classifier_rus.predict(X_test)
n_errors = (Y_pred_lr_rus_test != Y_test).sum()
print("\n\ntest")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_test,Y_pred_lr_rus_test))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_test,Y_pred_lr_rus_test))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_test,Y_pred_lr_rus_test))
print("AUC :",roc_auc_score(Y_test,lr_classifier_rus.predict_proba(X_test)[:,1]))
#Randomly undersampling non normalized training data
from imblearn.under_sampling import RandomUnderSampler
rus = RandomUnderSampler(random_state=42, replacement=False,sampling_strategy=0.002)
X1_train_rus, Y1_train_rus = rus.fit_resample(X1_train, Y1_train)
print('original train dataset shape:', Counter(Y_train))
print('Resample dataset shape', Counter(Y_train_rus))
#Applying decision tree classifier on randomly undersampled non normalized training data
dt_classifier_rus=DecisionTreeClassifier(criterion="entropy",random_state=0)
dt_classifier_rus.fit(X1_train_rus,Y1_train_rus)
Y1_pred_rus_dt_train=dt_classifier_rus.predict(X1_train_rus)
n_errors = (Y1_pred_rus_dt_train != Y1_train_rus).sum()
print("\n\ntrain")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y1_train_rus,Y1_pred_rus_dt_train))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y1_train_rus,Y1_pred_rus_dt_train))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y1_train_rus,Y1_pred_rus_dt_train))
print("AUC :",roc_auc_score(Y1_train_rus,dt_classifier_rus.predict_proba(X1_train_rus)[:,1]))
Y1_pred_rus_dt_vad=dt_classifier_rus.predict(X1_vad)
n_errors = (Y1_pred_rus_dt_vad != Y1_vad).sum()
print("\n\nvalidation")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y1_vad,Y1_pred_rus_dt_vad))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y1_vad,Y1_pred_rus_dt_vad))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y1_vad,Y1_pred_rus_dt_vad))
print("AUC :",roc_auc_score(Y1_vad,dt_classifier_rus.predict_proba(X1_vad)[:,1]))
Y_pred_dt_rus_test=dt_classifier_rus.predict(X_test)
n_errors = (Y_pred_dt_rus_test != Y_test).sum()
print("\n\ntest")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_test,Y_pred_dt_rus_test))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_test,Y_pred_dt_rus_test))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_test,Y_pred_dt_rus_test))
print("AUC :",roc_auc_score(Y_test,dt_classifier_rus.predict_proba(X_test)[:,1]))
#undersampling normalized data using tomeklinks
from imblearn.under_sampling import TomekLinks
tl=TomekLinks()
X_train_tl,Y_train_tl=tl.fit_resample(X_train,Y_train)
print('original train dataset shape:', Counter(Y_train))
print('Resample dataset shape', Counter(Y_train_tl))
#applying logistic regression on undersampled normalized data using tomeklinks
lr_classifier_tl=LogisticRegression(random_state=0).fit(X_train_tl,Y_train_tl)
Y_pred_lr_tl_train=lr_classifier_tl.predict(X_train_tl)
n_errors = (Y_pred_lr_tl_train != Y_train_tl).sum()
print("\n\ntrain")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_train_tl,Y_pred_lr_tl_train))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_train_tl,Y_pred_lr_tl_train))
print("_________________________________________________________________________________\n")
print("error: ",n_errors)
print("Accuracy Score :",accuracy_score(Y_train_tl,Y_pred_lr_tl_train))
print("AUC :",roc_auc_score(Y_train_tl,lr_classifier_tl.predict_proba(X_train_tl)[:,1]))
Y_pred_lr_tl_vad=lr_classifier_tl.predict(X_vad)
n_errors = (Y_pred_lr_tl_vad != Y_vad).sum()
print("\n\nvalidation")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_vad,Y_pred_lr_tl_vad))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_vad,Y_pred_lr_tl_vad))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_vad,Y_pred_lr_tl_vad))
print("AUC :",roc_auc_score(Y_vad,lr_classifier_tl.predict_proba(X_vad)[:,1]))
Y_pred_lr_tl_test=lr_classifier_tl.predict(X_test)
n_errors = (Y_pred_lr_tl_test != Y_test).sum()
print("\n\ntest")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_test,Y_pred_lr_tl_test))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_test,Y_pred_lr_tl_test))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_test,Y_pred_lr_tl_test))
print("AUC :",roc_auc_score(Y_test,lr_classifier_tl.predict_proba(X_test)[:,1]))
#undersampling non normalized training data using tomek links
from imblearn.under_sampling import TomekLinks
tl=TomekLinks()
X1_train_tl,Y1_train_tl=tl.fit_resample(X1_train,Y1_train)
print('original train dataset shape:', Counter(Y1_train))
print('Resample dataset shape', Counter(Y1_train_tl))
#applying decision tree classifier on non normalised training data undersampled by tomek link 
dt_classifier_tl=DecisionTreeClassifier(criterion="entropy",random_state=0)
dt_classifier_tl.fit(X1_train_tl,Y1_train_tl)
Y1_pred_dt_tl_train=dt_classifier_tl.predict(X1_train_tl)
n_errors = (Y1_pred_dt_tl_train != Y1_train_tl).sum()
print("\n\ntrain")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y1_train_tl,Y1_pred_dt_tl_train))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y1_train_tl,Y1_pred_dt_tl_train))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y1_train_tl,Y1_pred_dt_tl_train))
print("AUC :",roc_auc_score(Y1_train_tl,dt_classifier_tl.predict_proba(X1_train_tl)[:,1]))
Y1_pred_dt_tl_vad=dt_classifier_tl.predict(X1_vad)
n_errors = (Y1_pred_dt_tl_vad != Y1_vad).sum()
print("\n\nvalidation")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y1_vad,Y1_pred_dt_tl_vad))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y1_vad,Y1_pred_dt_tl_vad))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y1_vad,Y1_pred_dt_tl_vad))
print("AUC :",roc_auc_score(Y1_vad,dt_classifier_tl.predict_proba(X1_vad)[:,1]))
Y_pred_dt_tl_test=dt_classifier_tl.predict(X_test)
n_errors = (Y_pred_dt_tl_test != Y_test).sum()
print("\n\ntest")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_test,Y_pred_dt_tl_test))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_test,Y_pred_dt_tl_test))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_test,Y_pred_dt_tl_test))
print("AUC :",roc_auc_score(Y_test,dt_classifier_tl.predict_proba(X_test)[:,1]))
#Randomly over sampling training data
from imblearn.over_sampling import RandomOverSampler
ros = RandomOverSampler(random_state=42,sampling_strategy=0.007)
X_train_ros, Y_train_ros = ros.fit_resample(X_train, Y_train)
print('Original dataset shape', Counter(Y_train))
print('Resample dataset shape', Counter(Y_train_ros))
#Applying logistic regression on randomly oversampled normalized training data
lr_classifier_ros=LogisticRegression(random_state=0).fit(X_train_ros,Y_train_ros)
Y_pred_lr_ros_train=lr_classifier_ros.predict(X_train_ros)
n_errors = (Y_pred_lr_ros_train != Y_train_ros).sum()
print("\n\ntrain")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_train_ros,Y_pred_lr_ros_train))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_train_ros,Y_pred_lr_ros_train))
print("_________________________________________________________________________________\n")
print("error: ",n_errors)
print("Accuracy Score :",accuracy_score(Y_train_ros,Y_pred_lr_ros_train))
print("AUC :",roc_auc_score(Y_train_ros,lr_classifier_ros.predict_proba(X_train_ros)[:,1]))
Y_pred_lr_ros_vad=lr_classifier_ros.predict(X_vad)
n_errors = (Y_pred_lr_ros_vad != Y_vad).sum()
print("\n\nvalidation")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_vad,Y_pred_lr_ros_vad))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_vad,Y_pred_lr_ros_vad))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_vad,Y_pred_lr_ros_vad))
print("AUC :",roc_auc_score(Y_vad,lr_classifier_ros.predict_proba(X_vad)[:,1]))
Y_pred_lr_ros_test=lr_classifier_ros.predict(X_test)
n_errors = (Y_pred_lr_ros_test != Y_test).sum()
print("\n\ntest")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_test,Y_pred_lr_ros_test))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_test,Y_pred_lr_ros_test))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_test,Y_pred_lr_ros_test))
print("AUC :",roc_auc_score(Y_test,lr_classifier_ros.predict_proba(X_test)[:,1]))
#randomly oversampling non normalized training data
from imblearn.over_sampling import RandomOverSampler
ros = RandomOverSampler(random_state=42,sampling_strategy=0.007)
X1_train_ros, Y1_train_ros = ros.fit_resample(X1_train, Y1_train)
print('Original dataset shape', Counter(Y1_train))
print('Resample dataset shape', Counter(Y1_train_ros))
#implementing decision tree classifier on randomly oversampled non normalised data
dt_classifier_ros=DecisionTreeClassifier(criterion="entropy",random_state=0)
dt_classifier_ros.fit(X1_train_ros,Y1_train_ros)
Y1_pred_dt_ros_train=dt_classifier_ros.predict(X1_train_ros)
n_errors = (Y1_pred_dt_ros_train != Y1_train_ros).sum()
print("\n\ntrain")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y1_train_ros,Y1_pred_dt_ros_train))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y1_train_ros,Y1_pred_dt_ros_train))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y1_train_ros,Y1_pred_dt_ros_train))
print("AUC :",roc_auc_score(Y1_train_ros,dt_classifier_ros.predict_proba(X1_train_ros)[:,1]))
Y1_pred_dt_ros_vad=dt_classifier_ros.predict(X1_vad)
n_errors = (Y1_pred_dt_ros_vad != Y1_vad).sum()
print("\n\nvalidation")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y1_vad,Y1_pred_dt_ros_vad))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y1_vad,Y1_pred_dt_ros_vad))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y1_vad,Y1_pred_dt_ros_vad))
print("AUC :",roc_auc_score(Y1_vad,dt_classifier_ros.predict_proba(X1_vad)[:,1]))
Y_pred_dt_ros_test=dt_classifier_ros.predict(X_test)
n_errors = (Y_pred_dt_ros_test != Y_test).sum()
print("\n\ntest")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_test,Y_pred_dt_ros_test))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_test,Y_pred_dt_ros_test))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_test,Y_pred_dt_ros_test))
print("AUC :",roc_auc_score(Y_test,dt_classifier_ros.predict_proba(X_test)[:,1]))
#oversampling training data using smote
from imblearn.over_sampling import SMOTE
smote=SMOTE(random_state=9,sampling_strategy=0.009)
X_train_smote,Y_train_smote=smote.fit_resample(X_train,Y_train)
print('Original dataset shape', Counter(Y_train))
print('Resample dataset shape', Counter(Y_train_smote))
#Applying logistic regression on oversampled training data using smote
lr_classifier_smote=LogisticRegression(random_state=0).fit(X_train_smote,Y_train_smote)
Y_pred_lr_smote_train=lr_classifier_smote.predict(X_train_smote)
n_errors = (Y_pred_lr_smote_train != Y_train_smote).sum()
print("\n\ntrain")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_train_smote,Y_pred_lr_smote_train))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_train_smote,Y_pred_lr_smote_train))
print("_________________________________________________________________________________\n")
print("error: ",n_errors)
print("Accuracy Score :",accuracy_score(Y_train_smote,Y_pred_lr_smote_train))
print("AUC :",roc_auc_score(Y_train_smote,lr_classifier_smote.predict_proba(X_train_smote)[:,1]))
Y_pred_lr_smote_vad=lr_classifier_smote.predict(X_vad)
n_errors = (Y_pred_lr_smote_vad != Y_vad).sum()
print("\n\nvalidation")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_vad,Y_pred_lr_smote_vad))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_vad,Y_pred_lr_smote_vad))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_vad,Y_pred_lr_smote_vad))
print("AUC :",roc_auc_score(Y_vad,lr_classifier_smote.predict_proba(X_vad)[:,1]))
Y_pred_lr_smote_test=lr_classifier_smote.predict(X_test)
n_errors = (Y_pred_lr_smote_test != Y_test).sum()
print("\n\ntest")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_test,Y_pred_lr_smote_test))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_test,Y_pred_lr_smote_test))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_test,Y_pred_lr_smote_test))
print("AUC :",roc_auc_score(Y_test,lr_classifier_smote.predict_proba(X_test)[:,1]))
#oversampling non normalised data using smote
from imblearn.over_sampling import SMOTE
smote=SMOTE(random_state=9,sampling_strategy=0.009)
X1_train_smote,Y1_train_smote=smote.fit_resample(X1_train,Y1_train)
print('Original dataset shape', Counter(Y1_train))
print('Resample dataset shape', Counter(Y1_train_smote))
#applying decision tree classifer on oversampled non normalised training data through smote
dt_classifier_smote=DecisionTreeClassifier(criterion="entropy",random_state=0)
dt_classifier_smote.fit(X1_train_smote,Y1_train_smote)
Y1_pred_dt_smote_train=dt_classifier_smote.predict(X1_train_smote)
n_errors = (Y1_pred_dt_smote_train != Y1_train_smote).sum()
print("\n\ntrain")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y1_train_smote,Y1_pred_dt_smote_train))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y1_train_smote,Y1_pred_dt_smote_train))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y1_train_smote,Y1_pred_dt_smote_train))
print("AUC :",roc_auc_score(Y1_train_smote,dt_classifier_smote.predict_proba(X1_train_smote)[:,1]))
Y1_pred_dt_smote_vad=dt_classifier_smote.predict(X1_vad)
n_errors = (Y1_pred_dt_smote_vad != Y1_vad).sum()
print("\n\nvalidation")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y1_vad,Y1_pred_dt_smote_vad))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y1_vad,Y1_pred_dt_smote_vad))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y1_vad,Y1_pred_dt_smote_vad))
print("AUC :",roc_auc_score(Y1_vad,dt_classifier_smote.predict_proba(X1_vad)[:,1]))
Y_pred_dt_smote_test=dt_classifier_smote.predict(X_test)
n_errors = (Y_pred_dt_smote_test != Y_test).sum()
print("\n\ntest")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_test,Y_pred_dt_smote_test))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_test,Y_pred_dt_smote_test))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_test,Y_pred_dt_smote_test))
print("AUC :",roc_auc_score(Y_test,dt_classifier_smote.predict_proba(X_test)[:,1]))
#oversampling training data using ada
from imblearn.over_sampling import ADASYN 
ada = ADASYN(random_state=42,sampling_strategy=0.005)
X_train_ada,Y_train_ada = ada.fit_resample(X_train, Y_train)
print('Original dataset shape', Counter(Y_train))
print('Resample dataset shape', Counter(Y_train_ada))
#Applying logistic regression on oversampled training data using ada
lr_classifier_ada=LogisticRegression(random_state=0).fit(X_train_ada,Y_train_ada)
Y_pred_lr_ada_train=lr_classifier_ada.predict(X_train_ada)
n_errors = (Y_pred_lr_ada_train != Y_train_ada).sum()
print("\n\ntrain")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_train_ada,Y_pred_lr_ada_train))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_train_ada,Y_pred_lr_ada_train))
print("_________________________________________________________________________________\n")
print("error: ",n_errors)
print("Accuracy Score :",accuracy_score(Y_train_ada,Y_pred_lr_ada_train))
print("AUC :",roc_auc_score(Y_train_ada,lr_classifier_ada.predict_proba(X_train_ada)[:,1]))
Y_pred_lr_ada_vad=lr_classifier_ada.predict(X_vad)
n_errors = (Y_pred_lr_ada_vad != Y_vad).sum()
print("\n\nvalidation")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_vad,Y_pred_lr_ada_vad))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_vad,Y_pred_lr_ada_vad))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_vad,Y_pred_lr_ada_vad))
print("AUC :",roc_auc_score(Y_vad,lr_classifier_ada.predict_proba(X_vad)[:,1]))
Y_pred_lr_ada_test=lr_classifier_smote.predict(X_test)
n_errors = (Y_pred_lr_ada_test != Y_test).sum()
print("\n\ntest")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_test,Y_pred_lr_ada_test))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_test,Y_pred_lr_ada_test))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_test,Y_pred_lr_ada_test))
print("AUC :",roc_auc_score(Y_test,lr_classifier_ada.predict_proba(X_test)[:,1]))
#oversampling non normalised data using ada
from imblearn.over_sampling import ADASYN 
ada = ADASYN(random_state=42,sampling_strategy=0.005)
X1_train_ada,Y1_train_ada = ada.fit_resample(X1_train, Y1_train)
print('Original dataset shape', Counter(Y1_train))
print('Resample dataset shape', Counter(Y1_train_ada))
#applying decision tree classifier on oversampled non normalized training data data thrrough ada
dt_classifier_ada=DecisionTreeClassifier(criterion="entropy",random_state=0)
dt_classifier_ada.fit(X1_train_ada,Y1_train_ada)
Y1_pred_dt_ada_train=dt_classifier_ada.predict(X1_train_ada)
n_errors = (Y1_pred_dt_ada_train != Y1_train_ada).sum()
print("\n\ntrain")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y1_train_ada,Y1_pred_dt_ada_train))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y1_train_ada,Y1_pred_dt_ada_train))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y1_train_ada,Y1_pred_dt_ada_train))
print("AUC :",roc_auc_score(Y1_train_ada,dt_classifier_ada.predict_proba(X1_train_ada)[:,1]))
Y1_pred_dt_ada_vad=dt_classifier_ada.predict(X1_vad)
n_errors = (Y1_pred_dt_ada_vad != Y1_vad).sum()
print("\n\nvalidation")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y1_vad,Y1_pred_dt_ada_vad))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y1_vad,Y1_pred_dt_ada_vad))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y1_vad,Y1_pred_dt_ada_vad))
print("AUC :",roc_auc_score(Y1_vad,dt_classifier_ada.predict_proba(X1_vad)[:,1]))
Y_pred_dt_ada_test=dt_classifier_smote.predict(X_test)
n_errors = (Y_pred_dt_ada_test != Y_test).sum()
print("\n\ntest")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_test,Y_pred_dt_ada_test))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_test,Y_pred_dt_ada_test))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_test,Y_pred_dt_ada_test))
print("AUC :",roc_auc_score(Y_test,dt_classifier_ada.predict_proba(X_test)[:,1]))
#combination of smote and random under sampling with the help of pipeline
from collections import Counter
from sklearn.datasets import make_classification
from imblearn.over_sampling import SMOTE
from imblearn.under_sampling import RandomUnderSampler
from imblearn.pipeline import Pipeline
from matplotlib import pyplot
from numpy import where
over = SMOTE(sampling_strategy=0.01)
under = RandomUnderSampler(sampling_strategy=0.01)
steps = [('o', over), ('u', under)]
pipeline = Pipeline(steps=steps)
X_train_comb,Y_train_comb=pipeline.fit_resample(X_train, Y_train)
print('Original dataset shape', Counter(Y_train))
print('Resample dataset shape', Counter(Y_train_comb))
#implement logistic regression on the combined sampled dataset
lr_classifier_comb=LogisticRegression(random_state=0).fit(X_train_comb,Y_train_comb)
Y_pred_lr_comb_train=lr_classifier_comb.predict(X_train_comb)
n_errors = (Y_pred_lr_comb_train != Y_train_comb).sum()
print("\n\ntrain")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_train_comb,Y_pred_lr_comb_train))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_train_comb,Y_pred_lr_comb_train))
print("_________________________________________________________________________________\n")
print("error: ",n_errors)
print("Accuracy Score :",accuracy_score(Y_train_comb,Y_pred_lr_comb_train))
print("AUC :",roc_auc_score(Y_train_comb,lr_classifier_comb.predict_proba(X_train_comb)[:,1]))
Y_pred_lr_comb_vad=lr_classifier_comb.predict(X_vad)
n_errors = (Y_pred_lr_comb_vad != Y_vad).sum()
print("\n\nvalidation")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_vad,Y_pred_lr_comb_vad))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_vad,Y_pred_lr_comb_vad))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_vad,Y_pred_lr_comb_vad))
print("AUC :",roc_auc_score(Y_vad,lr_classifier_comb.predict_proba(X_vad)[:,1]))
Y_pred_lr_comb_test=lr_classifier_comb.predict(X_test)
n_errors = (Y_pred_lr_comb_test != Y_test).sum()
print("\n\ntest")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_test,Y_pred_lr_comb_test))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_test,Y_pred_lr_comb_test))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_test,Y_pred_lr_comb_test))
print("AUC :",roc_auc_score(Y_test,lr_classifier_comb.predict_proba(X_test)[:,1]))
#combination sampling on non normalised data
from collections import Counter
from sklearn.datasets import make_classification
from imblearn.over_sampling import SMOTE
from imblearn.under_sampling import RandomUnderSampler
from imblearn.pipeline import Pipeline
from matplotlib import pyplot
from numpy import where
over = SMOTE(sampling_strategy=0.002)
under = RandomUnderSampler(sampling_strategy=0.002)
steps = [('o', over), ('u', under)]
pipeline = Pipeline(steps=steps)
X1_train_comb,Y1_train_comb=pipeline.fit_resample(X1_train, Y1_train)
print('Original dataset shape', Counter(Y1_train))
print('Resample dataset shape', Counter(Y1_train_comb))
#applying decision tree classifier on combined sampled data
dt_classifier_comb=DecisionTreeClassifier(criterion="entropy",random_state=0)
dt_classifier_comb.fit(X1_train_comb,Y1_train_comb)
Y1_pred_dt_comb_train=dt_classifier_comb.predict(X1_train_comb)
n_errors = (Y1_pred_dt_comb_train != Y1_train_comb).sum()
print("\n\ntrain")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y1_train_comb,Y1_pred_dt_comb_train))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y1_train_comb,Y1_pred_dt_comb_train))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y1_train_comb,Y1_pred_dt_comb_train))
print("AUC :",roc_auc_score(Y1_train_comb,dt_classifier_comb.predict_proba(X1_train_comb)[:,1]))
Y1_pred_dt_comb_vad=dt_classifier_comb.predict(X1_vad)
n_errors = (Y1_pred_dt_comb_vad != Y1_vad).sum()
print("\n\nvalidation")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y1_vad,Y1_pred_dt_comb_vad))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y1_vad,Y1_pred_dt_comb_vad))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y1_vad,Y1_pred_dt_comb_vad))
print("AUC :",roc_auc_score(Y1_vad,dt_classifier_comb.predict_proba(X1_vad)[:,1]))
Y_pred_dt_comb_test=dt_classifier_comb.predict(X_test)
n_errors = (Y_pred_dt_comb_test != Y_test).sum()
print("\n\ntest")
print("_________________________________________________________________________________\n")
print("Classification Report :")
print(classification_report(Y_test,Y_pred_dt_comb_test))
print("_________________________________________________________________________________\n")
print("Confusion matrix")
print(confusion_matrix(Y_test,Y_pred_dt_comb_test))
print("_________________________________________________________________________________\n")
print("error: ",n_errors) 
print("Accuracy Score :",accuracy_score(Y_test,Y_pred_dt_comb_test))
print("AUC :",roc_auc_score(Y_test,dt_classifier_comb.predict_proba(X_test)[:,1]))